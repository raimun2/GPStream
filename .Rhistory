message("unsupported format")
}
return(stream_df) #return tibble with file stream
}
files <- testes <- list.files("inst/extdata")
for(fil in files){
df <- read_stream_file(paste0("inst/extdata/",fil))
head(df)
}
for(fil in files){
df <- read_stream_file(paste0("inst/extdata/",fil))
print(head(df))
}
fil
paste0("inst/extdata/",fil)
df <- read_stream_file(paste0("inst/extdata/",fil))
filename <- paste0("inst/extdata/",fil)
file_data <- FITfileR::readFitFile(filename)
stream_df <- FITfileR::records(file_data)
class(stream_df)
length(stream_df)
size(stream_df)
is.list(stream_df)
is.data.frame(stream_df)
#' Load GPS streams from a single gpx, kml, kmz, tcx or fit file and stores it in a Tibble
#' Allows to process files from Strava's bulk export, which includes compressed fit files (*.fit.gz)
#' @param filename The file path to the directory containing file
#' read_stream_file()
#'
#' @return
#' @export
#'
read_stream_file <- function(filename){
# if file ends in "*fit.gz" or "kmz", then unzip it, maintaining the original file
if(length(grep(".fit.gz",filename))==1) {
R.utils::gunzip(filename, remove=FALSE, overwrite=TRUE)
filename <- gsub(".gz$","",filename) # remove ".gz" from filename
} else if(length(grep(".kmz",filename))==1){
filename <- unzip(filename, exdir = dirname(filename))
}
# if fit file (including uncompressed file) use FITfileR library
if(length(grep(".fit$",filename))==1){
file_data <- FITfileR::readFitFile(filename)
stream_df <- FITfileR::records(file_data)
if(!is.data.frame(stream_df)){
stream_df <-  plyr::rbind.fill(lapply(stream_df,function(y){as.data.frame((y))})) %>% tibble::as_tibble()
}
} else if(length(grep(".gpx$",filename))==1) {
stream_df <- read_GPX(filename)
} else if(length(grep(".kml$",filename))==1) {
stream_df <- do.call("rbind", maptools::getKMLcoordinates(filename)) %>% as_tibble()
colnames(stream_df)[1:ncol(stream_df)] <- c("lon", "lat", "ele")[1:ncol(stream_df)]
} else if(length(grep(".tcx$",filename))==1) {
doc <- XML::xmlParse("inst/extdata/st3.tcx")
nodes <- XML::getNodeSet(doc, "//ns:Trackpoint", "ns")
rows <-  lapply(nodes, function(x) data.frame(XML::xmlToList(x) ))
stream_df <- do.call("rbind", rows) %>% as_tibble()
} else {
message("unsupported format")
}
return(stream_df) #return tibble with file stream
}
for(fil in files){
df <- read_stream_file(paste0("inst/extdata/",fil))
print(head(df))
}
#' Load GPS streams from a single gpx, kml, kmz, tcx or fit file and stores it in a Tibble
#' Allows to process files from Strava's bulk export, which includes compressed fit files (*.fit.gz)
#' @param filename The file path to the directory containing file
#' read_stream_file()
#'
#' @return
#' @export
#'
read_stream_file <- function(filename){
# if file ends in "*fit.gz" or "kmz", then unzip it, maintaining the original file
if(length(grep(".fit.gz",filename))==1) {
R.utils::gunzip(filename, remove=FALSE, overwrite=TRUE)
filename <- gsub(".gz$","",filename) # remove ".gz" from filename
} else if(length(grep(".kmz",filename))==1){
filename <- unzip(filename, exdir = dirname(filename))
}
# if fit file (including uncompressed file) use FITfileR library
if(length(grep(".fit$",filename))==1){
file_data <- FITfileR::readFitFile(filename)
stream_df <- FITfileR::records(file_data)
if(!is.data.frame(stream_df)){
stream_df <-  plyr::rbind.fill(lapply(stream_df,function(y){as.data.frame((y))}))
}
} else if(length(grep(".gpx$",filename))==1) {
stream_df <- read_GPX(filename)
} else if(length(grep(".kml$",filename))==1) {
stream_df <- do.call("rbind", maptools::getKMLcoordinates(filename))
colnames(stream_df)[1:ncol(stream_df)] <- c("lon", "lat", "ele")[1:ncol(stream_df)]
} else if(length(grep(".tcx$",filename))==1) {
doc <- XML::xmlParse("inst/extdata/st3.tcx")
nodes <- XML::getNodeSet(doc, "//ns:Trackpoint", "ns")
rows <-  lapply(nodes, function(x) data.frame(XML::xmlToList(x) ))
stream_df <- do.call("rbind", rows)
} else {
message("unsupported format")
}
return(stream_df %>% tibble::as_tibble()) #return tibble with file stream
}
for(fil in files){
df <- read_stream_file(paste0("inst/extdata/",fil))
print(head(df))
}
for(fil in files){
df <- read_stream_file(paste0("inst/extdata/",fil))
print(str(df))
}
files <- testes <- list.files("inst/extdata")
for(fil in files){
df <- read_stream_file(paste0("inst/extdata/",fil))
print(str(df))
}
exists("time", df)
print(exists("ime", df))
print(exists("Time", df))
?exists
print(exists("(t|T)ime", df))
print(exists("Time", df))
print(contains("Time", df))
df[,grepl("Sepal", colnames(df))]
df[,grepl("Time", colnames(df))]
df[,grepl("Lon", colnames(df))]
df[,grepl("(l|L)on", colnames(df))]
df[,grepl("(l|L)on|lng", colnames(df))]
df[,grepl("(l|L)on|(l|L)ng", colnames(df))]
print(df[,grepl("(l|L)on|(l|L)ng", colnames(df))])
for(fil in files){
df <- read_stream_file(paste0("inst/extdata/",fil))
print(df[,grepl("(l|L)on|(l|L)ng", colnames(df))])
}
grepl("(l|L)on|(l|L)ng", colnames(df)
)
print(colnames(grepl("(l|L)on|(l|L)ng", colnames(df))))
print(colnames(df)[grepl("(l|L)on|(l|L)ng", colnames(df))])
print(colnames(df)[grepl("(l|L)on|(l|L)ng", colnames(df))])
print(colnames(df)[grepl("dds", colnames(df))])
colnames(df)[grepl("jj", colnames(df))] <- "lon"
View(df)
colnames(df)[grepl("jj", colnames(df))]
colnames(df)[grepl("jj", colnames(df))] <- "lon"
colnames(df)
colnames(data)[grepl("(l|L)at", colnames(data))]
for(fil in files){
data <- read_stream_file(paste0("inst/extdata/",fil))
print(colnames(data)[grepl("(l|L)at", colnames(data))])
}
print(colnames(data)[grepl("(E|e)le|(a|A)lti", colnames(data))]))
print(colnames(data)[grepl("(E|e)le|(a|A)lti", colnames(data))])
for(fil in files){
data <- read_stream_file(paste0("inst/extdata/",fil))
print(colnames(data)[grepl("(E|e)le|(a|A)lti", colnames(data))])
}
print(colnames(data)[grepl("(c|C)ad", colnames(data))])
for(fil in files){
data <- read_stream_file(paste0("inst/extdata/",fil))
print(colnames(data)[grepl("(c|C)ad", colnames(data))])
}
class(data)
str(data)
print(colnames(data)[grepl("(t|T)ime", colnames(data))])
for(fil in files){
data <- read_stream_file(paste0("inst/extdata/",fil))
print(colnames(data)[grepl("(t|T)ime", colnames(data))])
}
timecols <- colnames(data)[grepl("(t|T)ime", colnames(data))]
timecols <- grepl("(t|T)ime", colnames(data))
sum(timcols)
sum(timecols)
df_time <- data[,timecols]
View(df_time)
class(df_time$Time)
as_datetime(df_time$Time)
lubridate::as_datetime(df_time$Time)
lubridate::as_datetime(df_time)
lubridate::as_datetime(data$Position.LatitudeDegrees)
apply(data,2,function(x) lubridate::as_datetime(x))
df_time <- data[,timecols]
apply(df_time,2,function(x) lubridate::as_datetime(x))
View(df_time)
df_time <- apply(df_time,2,function(x) lubridate::as_datetime(x))
View(df_time)
df_time <- apply(df_time, 2, function(x) lubridate::as_datetime(x))
print(colnames(data)[grepl("(t|T)ime", colnames(data))])
apply(df_time, 2, function(x) lubridate::as_numeric(x))
df_time <- apply(df_time, 2, function(x) lubridate::as.numeric(x))
df_time <- apply(df_time, 2, function(x) s.numeric(x))
df_time <- apply(df_time, 2, function(x) as.numeric(x))
df_time <- data[,timecols]
df_time <- apply(df_time, 2, function(x) as.numeric(x))
View(df_time)
is.POSIXt(data)
lubridate::is.POSIXt(data)
df_time <- data[,timecols]
class(data[,timecols])
df_time <- data %>% pull(timecols)
df_time <- data %>% pull(colnames(data)[timecols])
as_datetime(df_time)
lubridate::as_datetime(df_time)
lubridate::as_datetime(1:1999)
as.numeric(df_time)
is.na(as.numeric(df_time))
mean(is.na(as.numeric(df_time)))
mean(is.na(as.numeric(df_time))) == 1
colnames(data)[grepl("(t|T)ime", colnames(data))] <- "timestamp"
data$timestamp <- lubridate::as_datetime(df_time)
data$time <- as.numeric(data$timestamp - min(data$timestamp))
data$time
data$timestamp
4*60*60
data$time
4*60*60
as.numeric(data$lat)
exists("ele",data)
data %>% dplyr::relocate(lon, lat)
#' Rename GPS streams according to convention long, lat, elev, timestamp and time. If variable time is missing, the algorithm will aggregate a variable 'time' defined as seconds from start.
#' The algorithm identify some typical names for longitude, latitude, elevation and time. Then raname variables, order it and return a dataframe. If some of this variables is missing or dosen't have a typical name, the return will only have renamed entry variables.
#'
#' @param data is a dataframe or tibble containing a GPS stream. The stream dataframe can be obtained from rStrva library.(see rStrava documentation)
#'
#' rename_stream()
#'
#' @return dataframe stream with 'lon', 'lat', 'ele' and 'time' variables.
#' @export
#'
rename_stream <- function(data){
# rename variables as convention lon, lat, ele, timestamp and time
colnames(data)[grepl("(l|L)on|(l|L)ng", colnames(data))] <- "lon"
colnames(data)[grepl("(l|L)at", colnames(data))] <- "lat"
colnames(data)[grepl("(E|e)le|(a|A)lti", colnames(data))] <- "ele"
timecols <- grepl("(t|T)ime", colnames(data))
if(sum(timecols)==1){
df_time <- data %>% pull(colnames(data)[timecols])
if(mean(is.na(as.numeric(df_time))) == 1){
colnames(data)[grepl("(t|T)ime", colnames(data))] <- "timestamp"
data$timestamp <- lubridate::as_datetime(df_time)
data$time <- as.numeric(data$timestamp - min(data$timestamp))
} else {
colnames(data)[grepl("(t|T)ime", colnames(data))] <- "time"
data$time <- as.numeric(df_time)
}
}
data$lon <- as.numeric(data$lon)
data$lat <- as.numeric(data$lat)
if(exists("ele",data)){
data$ele <- as.numeric(data$ele)
data <- data %>% dplyr::relocate(ele)
}
# reorder renamed columns to the front
data <- data %>% dplyr::relocate(lon, lat)
# return uniformed stream
return(data)
}
#' Load GPS streams from a single gpx, kml, kmz, tcx or fit file and stores it in a Tibble
#' Allows to process files from Strava's bulk export, which includes compressed fit files (*.fit.gz)
#' @param filename The file path to the directory containing file
#' read_stream()
#'
#' @return
#' @export
#'
read_stream <- function(filename){
# if file ends in "*fit.gz" or "kmz", then unzip it, maintaining the original file
if(length(grep(".fit.gz",filename))==1) {
R.utils::gunzip(filename, remove=FALSE, overwrite=TRUE)
filename <- gsub(".gz$","",filename) # remove ".gz" from filename
} else if(length(grep(".kmz",filename))==1){
filename <- unzip(filename, exdir = dirname(filename))
}
# if fit file (including uncompressed file) use FITfileR library
if(length(grep(".fit$",filename))==1){
file_data <- FITfileR::readFitFile(filename)
stream_df <- FITfileR::records(file_data)
if(!is.data.frame(stream_df)){
stream_df <-  plyr::rbind.fill(lapply(stream_df,function(y){as.data.frame((y))}))
}
} else if(length(grep(".gpx$",filename))==1) {
stream_df <- read_GPX(filename)
} else if(length(grep(".kml$",filename))==1) {
stream_df <- do.call("rbind", maptools::getKMLcoordinates(filename))
colnames(stream_df)[1:ncol(stream_df)] <- c("lon", "lat", "ele")[1:ncol(stream_df)]
} else if(length(grep(".tcx$",filename))==1) {
doc <- XML::xmlParse("inst/extdata/st3.tcx")
nodes <- XML::getNodeSet(doc, "//ns:Trackpoint", "ns")
rows <-  lapply(nodes, function(x) data.frame(XML::xmlToList(x) ))
stream_df <- do.call("rbind", rows)
} else {
message("unsupported format")
}
return(stream_df %>% tibble::as_tibble()) #return tibble with file stream
}
#' Rename GPS streams according to convention long, lat, elev, timestamp and time. If variable time is missing, the algorithm will aggregate a variable 'time' defined as seconds from start.
#' The algorithm identify some typical names for longitude, latitude, elevation and time. Then raname variables, order it and return a dataframe. If some of this variables is missing or dosen't have a typical name, the return will only have renamed entry variables.
#'
#' @param data is a dataframe or tibble containing a GPS stream. The stream dataframe can be obtained from rStrva library.(see rStrava documentation)
#'
#' rename_stream()
#'
#' @return dataframe stream with 'lon', 'lat', 'ele' and 'time' variables.
#' @export
#'
rename_stream <- function(data){
# rename variables as convention lon, lat, ele, timestamp and time
colnames(data)[grepl("(l|L)on|(l|L)ng", colnames(data))] <- "lon"
colnames(data)[grepl("(l|L)at", colnames(data))] <- "lat"
colnames(data)[grepl("(E|e)le|(a|A)lti", colnames(data))] <- "ele"
timecols <- grepl("(t|T)ime", colnames(data))
if(sum(timecols)==1){
df_time <- data %>% pull(colnames(data)[timecols])
if(mean(is.na(as.numeric(df_time))) == 1){
colnames(data)[grepl("(t|T)ime", colnames(data))] <- "timestamp"
data$timestamp <- lubridate::as_datetime(df_time)
data$time <- as.numeric(data$timestamp - min(data$timestamp))
} else {
colnames(data)[grepl("(t|T)ime", colnames(data))] <- "time"
data$time <- as.numeric(df_time)
}
}
data$lon <- as.numeric(data$lon)
data$lat <- as.numeric(data$lat)
if(exists("ele",data)){
data$ele <- as.numeric(data$ele)
data <- data %>% dplyr::relocate(ele)
}
# reorder renamed columns to the front
data <- data %>% dplyr::relocate(lon, lat)
# return uniformed stream
return(data)
}
prin(head(data))
print(head(data))
for(fil in files){
data <- read_stream(paste0("inst/extdata/",fil)) %>%
rename_stream()
print(head(data))
}
if(mean(is.na(as.numeric(df_time), warning =  FALSE)) == 1){
colnames(data)[grepl("(t|T)ime", colnames(data))] <- "timestamp"
data$timestamp <- lubridate::as_datetime(df_time)
data$time <- as.numeric(data$timestamp - min(data$timestamp))
} else {
colnames(data)[grepl("(t|T)ime", colnames(data))] <- "time"
data$time <- as.numeric(df_time)
}
if(mean(is.na(as.numeric(df_time))) == 1){
colnames(data)[grepl("(t|T)ime", colnames(data))] <- "timestamp"
data$timestamp <- lubridate::as_datetime(df_time)
data$time <- as.numeric(data$timestamp - min(data$timestamp))
} else {
colnames(data)[grepl("(t|T)ime", colnames(data))] <- "time"
data$time <- as.numeric(df_time)
}
if(mean(is.na(as.numeric(df_time)), na.rm = TRUE) == 1){
colnames(data)[grepl("(t|T)ime", colnames(data))] <- "timestamp"
data$timestamp <- lubridate::as_datetime(df_time)
data$time <- as.numeric(data$timestamp - min(data$timestamp))
} else {
colnames(data)[grepl("(t|T)ime", colnames(data))] <- "time"
data$time <- as.numeric(df_time)
}
if(mean(is.na(as.numeric(df_time))) == 1){
colnames(data)[grepl("(t|T)ime", colnames(data))] <- "timestamp"
data$timestamp <- lubridate::as_datetime(df_time)
data$time <- as.numeric(data$timestamp - min(data$timestamp))
} else {
colnames(data)[grepl("(t|T)ime", colnames(data))] <- "time"
data$time <- as.numeric(df_time)
}
if(suppressWarnings(mean(is.na(as.numeric(df_time))))  == 1){
colnames(data)[grepl("(t|T)ime", colnames(data))] <- "timestamp"
data$timestamp <- lubridate::as_datetime(df_time)
data$time <- as.numeric(data$timestamp - min(data$timestamp))
} else {
colnames(data)[grepl("(t|T)ime", colnames(data))] <- "time"
data$time <- as.numeric(df_time)
}
df_time <- data %>% pull(colnames(data)[timecols])
timecols <- grepl("(t|T)ime", colnames(data))
df_time <- data %>% pull(colnames(data)[timecols])
as_datetime(df_time)
lubridate::as_datetime(df_time)
lubridate::as_datetime(1:2)
is.numeric(df_time)
class(df_time)
colnames(data)[grepl("(t|T)ime", colnames(data))] <- "time"
#' Rename GPS streams according to convention long, lat, elev, timestamp and time. If variable time is missing, the algorithm will aggregate a variable 'time' defined as seconds from start.
#' The algorithm identify some typical names for longitude, latitude, elevation and time. Then raname variables, order it and return a dataframe. If some of this variables is missing or dosen't have a typical name, the return will only have renamed entry variables.
#'
#' @param data is a dataframe or tibble containing a GPS stream. The stream dataframe can be obtained from rStrva library.(see rStrava documentation)
#'
#' rename_stream()
#'
#' @return dataframe stream with 'lon', 'lat', 'ele' and 'time' variables.
#' @export
#'
rename_stream <- function(data){
# rename variables as convention lon, lat, ele, timestamp and time
colnames(data)[grepl("(l|L)on|(l|L)ng", colnames(data))] <- "lon"
colnames(data)[grepl("(l|L)at", colnames(data))] <- "lat"
colnames(data)[grepl("(E|e)le|(a|A)lti", colnames(data))] <- "ele"
timecols <- grepl("(t|T)ime", colnames(data))
colnames(data)[grepl("(t|T)ime", colnames(data))] <- "time"
# if(sum(timecols)==1){
#   df_time <- data %>% pull(colnames(data)[timecols])
#   class(df_time)
#
#   lubridate::as_datetime(1:2)
#
#   if(suppressWarnings(mean(is.na(as.numeric(df_time))))  == 1){
#     colnames(data)[grepl("(t|T)ime", colnames(data))] <- "timestamp"
#     data$timestamp <- lubridate::as_datetime(df_time)
#     data$time <- as.numeric(data$timestamp - min(data$timestamp))
#   } else {
#     colnames(data)[grepl("(t|T)ime", colnames(data))] <- "time"
#     data$time <- as.numeric(df_time)
#   }
# }
data$lon <- as.numeric(data$lon)
data$lat <- as.numeric(data$lat)
if(exists("ele",data)){
data$ele <- as.numeric(data$ele)
data <- data %>% dplyr::relocate(ele)
}
# reorder renamed columns to the front
data <- data %>% dplyr::relocate(lon, lat)
# return uniformed stream
return(data)
}
for(fil in files){
data <- read_stream(paste0("inst/extdata/",fil)) %>%
rename_stream()
print(class(data$time))
}
print(is.numeric.POSIXt(data$time))
print(is.POSIXt(data$time))
print(lubridate::is.POSIXt(data$time))
print(lubridate::is.POSIXct(data$time))
print(is.Date(data$time))
is.numeric.Date(data$time)
for(fil in files){
data <- read_stream(paste0("inst/extdata/",fil)) %>%
rename_stream()
print(lubridate::is.POSIXt(data$time))
}
is.character(df_time)
df_time <- lubridate::as_datetime(df_time)
lubridate::is.POSIXt(data$time)
df_time <- data %>% pull(colnames(data)[timecols])
df_time <- lubridate::as_POSIxt(df_time)
lubridate::is.POSIcXt(data$time)
lubridate::is.POSIXct(data$time)
class(df_time)
lubridate::is.POSIXct(df_time)
df_time <- data %>% pull(colnames(data)[timecols])
timecols <- grepl("(t|T)ime", colnames(data))
df_time <- data %>% pull(colnames(data)[timecols])
is.character(df_time)
as.numeric(df_time)
#' Rename GPS streams according to convention long, lat, elev, timestamp and time. If variable time is missing, the algorithm will aggregate a variable 'time' defined as seconds from start.
#' The algorithm identify some typical names for longitude, latitude, elevation and time. Then raname variables, order it and return a dataframe. If some of this variables is missing or dosen't have a typical name, the return will only have renamed entry variables.
#'
#' @param data is a dataframe or tibble containing a GPS stream. The stream dataframe can be obtained from rStrva library.(see rStrava documentation)
#'
#' rename_stream()
#'
#' @return dataframe stream with 'lon', 'lat', 'ele' and 'time' variables.
#' @export
#'
rename_stream <- function(data){
# rename variables as convention lon, lat, ele, timestamp and time
colnames(data)[grepl("(l|L)on|(l|L)ng", colnames(data))] <- "lon"
colnames(data)[grepl("(l|L)at", colnames(data))] <- "lat"
colnames(data)[grepl("(E|e)le|(a|A)lti", colnames(data))] <- "ele"
timecols <- grepl("(t|T)ime", colnames(data))
if(sum(timecols)==1){
df_time <- data %>% pull(colnames(data)[timecols])
if(is.character(df_time)){
df_time <- lubridate::as_datetime(df_time)
}
if(lubridate::is.POSIXct(df_time)){
colnames(data)[grepl("(t|T)ime", colnames(data))] <- "timestamp"
data$timestamp <- lubridate::as_datetime(df_time)
data$time <- as.numeric(data$timestamp - min(data$timestamp))
} else {
colnames(data)[grepl("(t|T)ime", colnames(data))] <- "time"
data$time <- as.numeric(df_time)
}
data <- data %>% dplyr::relocate(time)
}
data$lon <- as.numeric(data$lon)
data$lat <- as.numeric(data$lat)
if(exists("ele",data)){
data$ele <- as.numeric(data$ele)
data <- data %>% dplyr::relocate(ele)
}
# reorder renamed columns to the front
data <- data %>% dplyr::relocate(lon, lat)
# return uniformed stream
return(data)
}
print(head(data))
for(fil in files){
data <- read_stream(paste0("inst/extdata/",fil)) %>%
rename_stream()
print(head(data))
}
fil
library(GPStream)
